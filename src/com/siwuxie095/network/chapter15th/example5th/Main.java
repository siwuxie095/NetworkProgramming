package com.siwuxie095.network.chapter15th.example5th;

/**
 * @author Jiajing Li
 * @date 2020-12-05 19:12:52
 */
public class Main {

    /**
     * Nifty 服务器的设计
     *
     * Nifty（https://github.com/facebook/nifty）是一个开源的、使用 Apache 许可的、构建于 Apache Thrift 库之上
     * 的 Thrift 客户端/服务器实现。它被专门设计，以便无缝地从任何其他的 Java Thrift 服务器实现迁移过来：你可以重用相
     * 同的 Thrift IDL 文件、相同的 Thrift 代码生成器（与 Apache Thrift 库打包在一起），以及相同的服务接口实现。唯
     * 一真正需要改变的只是你的服务器的启动代码（Nifty 的设置风格与 Apache Thrift 中的传统的 Thrift 服务器实现稍微有
     * 所不同）。
     *
     *
     * 1、Nifty 的编码器/解码器
     *
     * 默认的 Nifty 服务器能处理普通消息或者分帧消息（带有 4 字节的前缀）。它通过使用自定义的 Netty 帧解码器做到了这一
     * 点，其首先查看前几个字节，以确定如何对剩余的部分进行解码。然后，当发现了一个完整的消息时，解码器将会把消息的内容和
     * 一个指示了消息类型的字段包装在一起。服务器随后将会根据该字段来以相同的格式对响应进行编码。
     *
     * Nifty 还支持接驳你自己的自定义编解码器。例如，他们的一些服务使用了自定义的编解码器来从客户端在每条消息前面所插入
     * 的头部中读取额外的信息（包含可选的元数据、客户端的能力等）。解码器也可以被方便地扩展以处理其他类型的消息传输，如
     * HTTP。
     *
     *
     * 2、在服务器上排序响应
     *
     * Java Thrift 的初始版本使用了 OIO 套接字，并且服务器为每个活动连接都维护了一个线程。使用这种设置，在下一个响应被
     * 读取之前，每个请求都将在同一个线程中被读取、处理和应答。这保证了响应将总会以对应的请求所到达的顺序返回。
     *
     * 较新的异步 I/O 的服务器实现诞生了，其不需要每个连接一个线程，而且这些服务器可以处理更多的并发连接，但是客户端仍然
     * 主要使用同步 I/O，因此服务器可以期望它在发送当前响应之前，不会收到下一个请求。
     *
     * 客户端最初的伪异步用法开始于一些 Thrift 用户利用的一项事实：对于一个生成的客户端方法 foo() 来说，方法 send_foo()
     * 和 recv_foo() 将会被单独暴露出来。这使得 Thrift 用户可以发送多个请求（无论是在多个客户端上，还是在同一个客户端
     * 上），然后调用相应的接收方法来开始等待并收集结果。
     *
     * 在这个新的场景下，服务器可能会在它完成处理第一个请求之前，从单个客户端读取多个请求。在一个理想的世界中，可以假设所
     * 有流水线化请求的异步 Thrift 客户端都能够处理以任意顺序到达的这些请求所对应的响应。然而，在现实生活中，虽然新的客
     * 户端可以 处理这种情况，而那些旧一点的异步 Thrift 客户端可能会写出多个请求，但是必须要求按顺序接收响应。
     *
     * 这种问题可以通过使用 Netty 4 的 EventExecutor 或者 Netty 3.x 中的 OrderedMemoryAwareThreadPoolExcecutor
     * 解决，其能够保证顺序地处理同一个连接上的所有传入消息，而不会强制所有这些消息都在同一个执行器线程上运行。
     *
     * 尽管 Nifty 有着特殊的要求：他们的目标是以客户端能够处理的最佳的响应顺序服务于每个客户端。他们希望允许用于来自于单
     * 个连接上的多个流水线化的请求的处理器能够被并行处理，但是那样他们又控制不了这些处理器完成的先后顺序。
     *
     * 相反，他们使用了一种涉及缓冲响应的方案，如果客户端要求保持顺序的响应，他们将会缓冲后续的响应，直到所有较早的响应也
     * 可用，然后他们将按照所要求的顺序将它们一起发送出去。
     *
     * 当然，Nifty 包括了实实在在支持无序响应的异步 Channel（可以通过 Swift 使用）。当使用能够让客户端通知服务器此客户
     * 端的能力的自定义的传输时，服务器将会免除缓冲响应的负担，并且将以请求完成的任意顺序把它们发送回去。
     */
    public static void main(String[] args) {

    }

}
