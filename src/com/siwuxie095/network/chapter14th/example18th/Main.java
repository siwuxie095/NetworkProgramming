package com.siwuxie095.network.chapter14th.example18th;

/**
 * @author Jiajing Li
 * @date 2020-12-05 12:34:52
 */
public class Main {

    /**
     * 使用二进制协议的例子
     *
     * 苹果公司的 APNS 是一个具有特定的网络字节序的有效载荷的二进制协议。发送一个 APNS 通知将涉及下面的事件序列：
     * （1）通过 SSLv3 连接将 TCP 套接字连接到 APNS 服务器，并用 X.509 证书进行身份认证；
     * （2）根据 Apple 定义的格式，构造推送消息的二进制表示形式；
     * （3）将消息写出到套接字；
     * （4）如果你已经准备好了确定任何和已经发送的消息相关的错误代码，则从套接字中读取；
     * （5）如果有错误发生，则重新连接该套接字，并从步骤 2 继续。
     *
     * 作为格式化二进制消息的一部分，消息的生产者需要生成一个对于 APNS 系统透明的标识符。一旦消息无效（如不正确的
     * 格式、大小或者设备信息），那么该标识符将会在步骤 4 的错误响应消息中返回给客户端。
     *
     * 虽然从表面上看，该协议似乎简单明了，但是想要成功地解决所有上述问题，还是有一些微妙的细节，尤其是在 JVM 上。
     * （1）APNS 规范规定，特定的有效载荷值需要以大端字节序进行发送（如令牌长度）。
     * （2）在前面的操作序列中的第 3 步要求两个解决方案二选一。因为 JVM 不允许从一个已经关闭的套接字中读取数据，
     * 即使在输出缓冲区中有数据存在，所以你有两个选项。
     * 1）在一次写出操作之后，在该套接字上执行带有超时的阻塞读取动作。这种方式有多个缺点，具体如下：
     * a）阻塞等待错误消息的时间长短是不确定的。错误可能会发生在数毫秒或者数秒之内。
     * b）由于套接字对象无法在多个线程之间共享，所以在等待错误消息时，对套接字的写操作必须立即阻塞。这将对吞吐量
     * 造成巨大的影响。如果在一次套接字写操作中递交单个消息，那么在直到读取超时发生之前，该套接字上都不会发出更多
     * 的消息。当你要递交数千万的消息时，每个消息之间都有 3 秒的延迟是无法接受的。
     * c）依赖套接字超时是一项昂贵的操作。它将导致一个异常被抛出，以及几个不必要的系统调用。
     * 2）使用异步 I/O。在这个模型中，读操作和写操作都不会阻塞。这使得写入者可以持续地给 APNS 发送消息，同时也
     * 允许操作系统在数据可供读取时通知用户代码。
     *
     * Netty 使得可以轻松地解决所有的这些问题，同时提供了令人惊叹的吞吐量。
     *
     * Netty 可以简化使用正确的字节序打包二进制 APNS 消息。
     *
     * 同时，值得注意的是，Netty 使得协商结合了异步 I/O 的 X.509 认证的连接变得多么的容易。在 Urban Airship
     * 早期的没有使用 Netty 的原型 APNS 的代码中，协商一个异步的 X.509 认证的连接需要 80 多行代码和一个线程池，
     * 而这只仅仅是为了建立连接。Netty 隐藏了所有的复杂性，包括 SSL 握手、身份验证、最重要的将明文的字节加密为密
     * 文，以及使用 SSL 所带来的密钥的重新协商。这些 JDK 中异常无聊的、容易出错的并且缺乏文档的 API 都被隐藏在了
     * 3 行 Netty 代码之后。
     *
     * 在 Urban Airship，在所有和众多的包括 APNS 以及 Google 的 GCM 的第三方推送通知服务的连接中，Netty 都
     * 扮演了重要的角色。在每种情况下，Netty 都足够灵活，允许显式地控制从更高级别的 HTTP 的连接行为到基本的套接
     * 字级别的配置（如 TCP keep-alive 以及套接字缓冲区大小）的集成如何生效。
     *
     * 另外：部分摘要代码，可参考 PDF。
     */
    public static void main(String[] args) {

    }

}
