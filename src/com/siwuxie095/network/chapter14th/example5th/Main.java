package com.siwuxie095.network.chapter14th.example5th;

/**
 * @author Jiajing Li
 * @date 2020-12-04 08:17:15
 */
public class Main {

    /**
     * 创造一个更加快速的上传体验
     *
     * Droplr 的第一个版本的上传流程是相当地天真可爱：
     * （1）接收上传；
     * （2）上传到 S3；
     * （3）如果是图片，则创建略缩图；
     * （4）应答客户端应用程序。
     *
     * 更加仔细地看看这个流程，你很快便会发现在第 2 步和第 3 步上有两个瓶颈。不管从客户端上传到他们的服务器有多快，
     * 在实际的上传完成之后，直到成功地接收到响应之间，对于拖乐的创建总是会有恼人的间隔。因为对应的文件仍然需要被
     * 上传到 S3 中，并为其生成略缩图。
     *
     * 文件越大，间隔的时间也越长。对于非常大的文件来说，连接（指客户端和服务器之间的连接）最终将会在等待来自服务
     * 器的响应时超时。由于这个严重的问题，当时 Droplr 只可以提供单个文件最大 32MB 的上传能力。
     *
     * 有两种截然不同的方案来减少上传时间。
     * （1）方案 A，乐观且看似更加简单：
     * 1）完整地接收文件；
     * 2）将文件保存到本地的文件系统，并立即返回成功到客户端；
     * 3）计划在将来的某个时间点将其上传到 S3。
     *
     * （2）方案 B，安全但复杂：
     * 1）实时地（流式地）将从客户端上传的数据直接管道给 S3。
     *
     *
     *
     * 乐观且看似更加简单的方案
     *
     * 在收到文件之后便返回一个短 URL 创造了一个空想（也可以将其称为隐式的契约），即该文件立即在该 URL 地址上可用。
     * 但是并不能够保证，上传的第二阶段（实际将文件推送到 S3）也将最终会成功，那么用户可能会得到一个坏掉的链接，其
     * 可能已经被张贴到了 Twitter 或者发送给了一个重要的客户。这是不可接受的，即使是每十万次上传也只会发生一次。
     *
     * 他们当前的数据显示，他们的上传失败率略低于 0.01%（万分之一），绝大多数都是在上传实际完成之前，客户端和服务
     * 器之间的连接就超时了。
     *
     * 他们也可以尝试通过在文件被最终推送到 S3 之前，从接收它的机器提供该文件的服务来绕开它，然而这种做法本身就是
     * 一堆麻烦：
     * （1）如果在一批文件被完整地上传到 S3 之前，机器出现了故障，那么这些文件将会永久丢失；
     * （2）也将会有跨集群的同步问题（"这个拖乐所对应的文件在哪里呢？"）；
     * （3）将会需要额外的复杂的逻辑来处理各种边界情况，继而不断产生更多的边界情况。
     *
     * 在思考过每种变通方案和其陷阱之后，他很快认识到，这是一个经典的九头蛇问题 —— 对于每个砍下的头，它的位置上都
     * 会再长出两个头。
     *
     *
     *
     * 安全但复杂的方案
     *
     * 另一个选项需要对整体过程进行底层的控制。从本质上说，他们必须要能够做到以下几点。
     *
     * （1）在接收客户端上传文件的同时，打开一个到 S3 的连接；
     * （2）将从客户端连接上收到的数据管道给到 S3 的连接；
     * （3）缓冲并节流这两个连接：
     * 1）需要进行缓冲，以在客户端到服务器，以及服务器到 S3 这两个分支之间保持一条的稳定的流；
     * 2）需要进行节流，以防止当服务器到 S3 的分支上的速度变得慢于客户端到服务器的分支时，内存被消耗殆尽。
     * （4）当出现错误时，需要能够在两端进行彻底的回滚。
     *
     * 看起来概念上很简单，但是它并不是你的通常的 Web 服务器能够提供的能力。尤其是当你考虑节流一个 TCP 连接时，你
     * 需要对它的套接字进行底层的访问。
     *
     * 它同时也引入了一个新的挑战，其将最终塑造他们的终极架构：推迟略缩图的创建。
     *
     * 这也意味着，无论该平台最终构建于哪种技术栈之上，它都必须要不仅能够提供一些基本的特性，如难以置信的性能和稳定
     * 性，而且在必要时还要能够提供操作底层（即 字节级别的控制）的灵活性。
     */
    public static void main(String[] args) {

    }

}
