package com.siwuxie095.network.chapter14th.example6th;

/**
 * @author Jiajing Li
 * @date 2020-12-04 21:16:38
 */
public class Main {

    /**
     * 技术栈
     *
     * 当开始一个新的 Web 服务器项目时，最终你将会问自己："好吧，这些酷小子们这段时间都在用什么框架呢？"，他也是这样的。
     *
     * 选择 Netty 并不是一件无需动脑的事，他研究了大量的框架，并谨记他认为的 3 个至关重要的要素。
     * （1）它必须是快速的。他可不打算用一个低性能的技术栈替换另一个低性能的技术栈。
     * （2）它必须能够伸缩。不管它是有 1 个连接还是 10 000 个连接，每个服务器实例都必须要能够保持吞吐量，并且随着时间
     * 推移不能出现崩溃或者内存泄露。
     * （3）它必须提供对底层数据的控制。字节级别的读取、TCP 拥塞控制等，这些都是难点。
     *
     * 要素 1 和要素 2 基本上排除了任何非编译型的语言。他是 Ruby 语言的拥趸，并且热爱 Sinatra 和 Padrino 这样的轻
     * 量级框架，但是他知道他所追寻的性能是不可能通过这些构件块实现的。
     *
     * 要素 2 本身就意味着：无论是什么样的解决方案，它都不能依赖于阻塞 I/O。看到这里，你肯定已经明白为什么非阻塞 I/O
     * 是唯一的选择了。
     *
     * 要素 3 比较绕弯儿。它意味着必须要在一个框架中找到完美的平衡，它必须在提供了对于它所接收到的数据的底层控制的同时，
     * 也支持快速的开发，并且值得信赖。这便是语言、文档、社区以及其他的成功案例开始起作用的时候了。
     *
     * 在那时他有一种强烈的感觉：Netty 便是他的首选武器。
     *
     *
     *
     * 基本要素：服务器和流水线
     *
     * 服务器基本上只是一个 ServerBootstrap，其内置了 NioServerSocketChannelFactory， 配置了几个常见的
     * ChannelHandler 以及在末尾的 HTTP RequestController。
     *
     * RequestController 是 ChannelPipeline 中唯一自定义的 Droplr 代码，同时也可能是整个 Web 服务器中最复杂的部
     * 分。它的作用是处理初始请求的验证，并且如果一切都没问题，那么将会把请求路由到适当的请求处理器。对于每个已经建立的
     * 客户端连接，都会创建一个新的实例，并且只要连接保持活动就一直存在。
     *
     * 请求控制器负责：
     * （1）处理负载洪峰；
     * （2）HTTP ChannelPipeline 的管理；
     * （3）设置请求处理的上下文；
     * （4）派生新的请求处理器；
     * （5）向请求处理器供给数据；
     * （6）处理内部和外部的错误。
     *
     * 你应该永远不要在 Netty 的 I/O 线程上执行任何非 CPU 限定的代码 —— 你将会从 Netty 偷取宝贵的资源，并因此影响到
     * 服务器的吞吐量。
     *
     * 因此，HttpRequest 和 HttpChunk 都可以通过切换到另一个不同的线程，来将执行流程移交给请求处理器。当请求处理器不
     * 是 CPU 限定时，就会发生这样的情况，不管是因为它们访问了数据库，还是执行了不适合于本地内存或者 CPU 的逻辑。
     *
     * 当发生线程切换时，所有的代码块都必须要以串行的方式执行，否则，他们就会冒风险，对于一次上传来说，在处理完了序列号
     * 为 n 的 HttpChunk 之后，再处理序列号为 n -1 的 HttpChunk 必然会导致文件内容的损坏（他们可能会交错所上传的文
     * 件的字节布局）。为了处理这种情况，他创建了一个自定义的线程池执行器，其确保了所有共享了同一个通用标识符的任务都将
     * 以串行的方式被执行。
     *
     * 从这里开始，这些数据（请求和 HttpChunk）便开始了在 Netty 和 Droplr 王国之外的冒险。
     *
     * 下面将简短地解释请求处理器是如何被构建的，以在 RequestController（其存在于 Netty 的领地）和这些处理器（存在于
     * Droplr 的领地）之间的桥梁上亮起一些光芒。谁知道呢，这也许将会帮助你架构你自己的服务器应用程序呢！
     *
     *
     *
     * 请求处理器
     *
     * 请求处理器提供了 Droplr 的功能。它们是类似地址为 /account 或者 /drops 这样的 URI 背后的端点。它们是逻辑核心
     * —— 服务器对于客户端请求的解释器。
     *
     * 请求处理器的实现也是（Netty）框架实际上成为了 Droplr 的 API 服务器的地方。
     *
     *
     *
     * 父接口
     *
     * 每个请求处理器，不管是直接的还是通过子类继承，都是 RequestHandler 接口的实现。
     *
     * 其本质上，RequestHandler 接口表示了一个对于请求（HttpRequest 的实例）和分块（HttpChunk 的实例）的无状态处理
     * 器。它是一个非常简单的接口，包含了一组方法以帮助请求控制器来执行以及/或者决定如何执行它的职责，例如：
     * （1）请求处理器是有状态的还是无状态的呢？它需要从某个原型克隆，还是原型本身就可以用来处理请求呢？
     * （2）请求处理器是 CPU 限定的还是非 CPU 限定的呢？它可以在 Netty 的工作线程上执行，还是需要在一个单独的线程池中
     * 执行呢？
     * （3）回滚当前的变更；
     * （4）清理任何使用过的资源。
     *
     * 这个接口就是 RequestController 对于相关动作的所有理解。通过它非常清晰和简洁的接口，该控制器可以和有状态的和无
     * 状态的、CPU 限定的和非 CPU 限定的（或者这些性质的组合）处理器以一种独立的并且实现无关的方式进行交互。
     *
     *
     *
     * 处理器的实现
     *
     * 最简单的 RequestHandler 实现是 AbstractRequestHandler，它代表一个子类型的层次结构的根，在到达提供了所有
     * Droplr 的功能的实际处理器之前，它将变得愈发具体。最终，它会到达有状态的实现 SimpleHandler，它在一个非 I/O
     * 工作线程中执行，因此也不是 CPU 限定的。SimpleHandler 是快速实现那些执行读取 JSON 格式的数据、访问数据库，
     * 然后写出一些 JSON 的典型任务的端点的理想选择。
     *
     *
     *
     * 上传请求处理器
     *
     * 上传请求处理器是整个 Droplr API 服务器的关键。它是对于重塑 webserver 模块 —— 服务器的框架化部分的设计的响应，
     * 也是到目前为止整个技术栈中最复杂、最优化的代码部分。
     *
     * 在上传的过程中，服务器具有双重行为：
     * （1）在一边，它充当了正在上传文件的 API 客户端的服务器；
     * （2）在另一边，它充当了 S3 的客户端，以推送它从 API 客户端接收的数据。
     *
     * 为了充当客户端，服务器使用了一个同样使用 Netty 构建的 HTTP 客户端库。这个异步的 HTTP 客户端库暴露了一组完美匹配
     * 该服务器的需求的接口。它将开始执行一个 HTTP 请求，并允许在数据变得可用时再供给给它，而这大大地降低了上传请求处理器
     * 的客户门面的复杂性。
     *
     * PS：你可以在 https://github.com/brunodecarvalho/http-client 找到这个 HTTP 客户端库。但这个 HTTP 客户端
     * 库已经废弃，推荐 AsyncHttpClient（https://github.com/AsyncHttpClient/async-http-client）和 Akka-HTTP
     * （https://github.com/akka/akka-http），它们都实现了相同的功能。
     *
     * 另外：部分摘要代码，可参考 PDF。
     */
    public static void main(String[] args) {

    }

}
