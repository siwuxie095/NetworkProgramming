package com.siwuxie095.network.chapter14th.example11th;

/**
 * @author Jiajing Li
 * @date 2020-12-05 10:11:19
 */
public class Main {

    /**
     * 长轮询
     *
     * Firebase 同时使用了长轮询和 WebSocket 传输。长轮询传输是高度可靠的，覆盖了所有的浏览器、网络以及运营商，
     * 而基于 WebSocket 的传输，速度更快，但是由于浏览器/客户端的局限性，并不总是可用的。开始时，Firebase 将会
     * 使用长轮询进行连接，然后在 WebSocket 可用时再升级到 WebSocket。对于少数不支持 WebSocket 的 Firebase
     * 流量，Firebase 使用 Netty 实现了一个自定义的库来进行长轮询，并且经过调优具有非常高的性能和响应性。
     *
     * Firebase 的客户端库逻辑处理双向消息流，并且会在任意一端关闭流时进行通知。虽然这在 TCP 或者 WebSocket
     * 协议上实现起来相对简单，但是在处理长轮询传输时它仍然是一项挑战。对于长轮询的场景来说，下面两个属性必须被严
     * 格地保证：
     * （1）保证消息的按顺序投递；
     * （2）关闭通知。
     *
     *
     *
     * 保证消息的按顺序投递
     *
     * 可以通过使得在某个指定的时刻有且只有一个未完成的请求，来实现长轮询的按顺序投递。因为客户端不会在它收到它的
     * 上一个请求的响应之前发出另一个请求，所以这就保证了它之前所发出的所有消息都被接收，并且可以安全地发送更多的
     * 请求了。同样，在服务器端，直到客户端收到之前的响应之前，将不会发出新的请求。因此，总是可以安全地发送缓存在
     * 两个请求之间的任何东西。然而，这将导致一个严重的缺陷。使用单一请求技术，客户端和服务器端都将花费大量的时间
     * 来对消息进行缓冲。例如，如果客户端有新的数据需要发送，但是这时已经有了一个未完成的请求，那么它在发出新请求
     * 之前，就必须得等待服务器的响应。如果这时在服务器上没有可用的数据，则可能需要很长的时间。
     *
     * 一个更加高性能的解决方案则是容忍更多的正在并发进行的请求。在实践中，这可以通过将单一请求的模式切换为最多两
     * 个请求的模式。这个算法包含了两个部分：
     * （1）每当客户端有新的数据需要发送时，它都会发送一个新的请求，除非已经有了两个请求正在被处理；
     * （2）每当服务器接收到来自客户端的请求时，如果它已经有了一个来自客户端的未完成的请求，那么即使没有数据，它
     * 也将立即回应第一个请求。
     *
     * 相对于单一请求的模式，这种方式提供了一个重要的改进：客户端和服务器的缓冲时间都被限定在了最多一次的网络往返
     * 时间里。
     *
     * 当然，这种性能的增加并不是没有代价的。它导致了代码复杂性的相应增加。该长轮询算法也不再保证消息的按顺序投递，
     * 但是一些来自 TCP 协议的理念可以保证这些消息的按顺序投递。由客户端发送的每个请求都包含一个序列号，每次请求
     * 时都将会递增。此外，每个请求都包含了关于有效负载中的消息数量的元数据。如果一个消息跨越了多个请求，那么在有
     * 效负载中所包含的消息的序号也会被包含在元数据中。
     *
     * 服务器维护了一个传入消息分段的环形缓冲区，在它们完成之后，如果它们之前没有不完整的消息，那么会立即对它们进
     * 行处理。下行要简单点，因为长轮询传输响应的是 HTTP GET 请求，而且对于有效载荷的大小没有相同的限制。在这种
     * 情况下，将包含一个对于每个响应都将会递增的序列号。只要客户端接收到了达到指定序列号的所有响应，它就可以开始
     * 处理列表中的所有消息，如果它还没有收到，那么它将缓冲该列表，直到它接收到了这些未完成的响应。
     *
     *
     *
     * 关闭通知
     *
     * 在长轮询传输中第二个需要保证的属性是关闭通知。在这种情况下，使得服务器意识到传输已经关闭，明显要重要于使得
     * 客户端识别到传输的关闭。客户端所使用的 Firebase 库将会在连接断开时将操作放入队列以便稍后执行，而且这些被
     * 放入队列的操作可能也会对其他仍然连接着的客户端造成影响。因此，知道客户端什么时候实际上已经断开了是非常重要
     * 的。实现由服务器发起的关闭操作是相对简单的，其可以通过使用一个特殊的协议级别的关闭消息响应下一个请求来实现。
     *
     * 实现客户端的关闭通知是比较棘手的。虽然可以使用相同的关闭通知，但是有两种情况可能会导致这种方式失效：用户可
     * 以关闭浏览器标签页，或者网络连接也可能会消失。标签页关闭的这种情况可以通过 iframe 来处理，iframe 会在页
     * 面卸载时发送一个包含关闭消息的请求。第二种情况则可以通过服务器端超时来处理。小心谨慎地选择超时值大小很重要，
     * 因为服务器无法区分慢速的网络和断开的客户端。也就是说，对于服务器来说，无法知道一个请求是被实际推迟了一分钟，
     * 还是该客户端丢失了它的网络连接。相对于应用程序需要多快地意识到断开的客户端来说，选取一个平衡了误报所带来的
     * 成本（关闭慢速网络上的客户端的传输）的合适的超时大小是很重要的。
     *
     * Firebase 的长轮询传输是如何处理不同类型的请求呢？
     *
     * 以场景为例，每个长轮询请求都代表了不同类型的场景。
     *
     * 最初，客户端向服务器发送了一个轮询（轮询 0）。一段时间之后，服务器从系统内的其他地方接收到了发送给该客户端
     * 的数据，所以它使用该数据响应了轮询 0。在该轮询返回之后，因为客户端目前没有任何未完成的请求，所以客户端又立
     * 即发送了一个新的轮询（轮询 1）。过了一小会儿，客户端需要发送数据给服务器。因为它只有一个未完成的轮询，所以
     * 它又发送了一个新的轮询（轮询 2），其中包含了需要被递交的数据。根据协议，一旦在服务器同时存在两个来自相同的
     * 客户端的轮询时，它将响应第一个轮询。在这种情况下，服务器没有任何已经就绪的数据可以用于该客户端，因此它发送
     * 回了一个空响应。客户端也维护了一个超时，并将在超时被触发时发送第二次轮询，即使它没有任何额外的数据需要发送。
     * 这将系统从由于浏览器超时缓慢的请求所导致的故障中隔离开来。
     */
    public static void main(String[] args) {

    }

}
