package com.siwuxie095.network.chapter7th.example2nd;

/**
 * @author Jiajing Li
 * @date 2020-11-18 08:12:44
 */
public class Main {

    /**
     * 线程模型概述
     *
     * 这里将介绍常见的线程模型，随后将继续讨论 Netty 过去以及当前的线程模型，并评审它们各自的优点以及局限性。
     *
     * 线程模型确定了代码的执行方式。由于总是必须规避并发执行可能会带来的副作用，所以理解所采用的并发模型（也
     * 有单线程的线程模型）的影响很重要。忽略这些问题，仅寄希望于最好的情况（不会引发并发问题）无疑是赌博 ——
     * 赔率必然会击败你。
     *
     * 因为具有多核心或多个 CPU 的计算机现在已经司空见惯，大多数的现代应用程序都利用了复杂的多线程处理技术以
     * 有效地利用系统资源。相比之下，在早期的 Java 语言中，使用多线程处理的主要方式无非是按需创建和启动新的
     * Thread 来执行并发的任务单元 —— 一种在高负载下工作得很差的原始方式。Java 5 随后引入了 Executor API，
     * 其线程池通过缓存和重用 Thread 极大地提高了性能。
     *
     * 基本的线程池化模式可以描述为：
     * （1）从池的空闲线程列表中选择一个 Thread，并且指派它去运行一个已提交的任务（一个 Runnable 的实现）；
     * （2）当任务完成时，将该 Thread 返回给该列表，使其可被重用。
     *
     * 虽然池化和重用线程相对于简单地为每个任务都创建和销毁线程是一种进步，但是它并不能消除由上下文切换所带来
     * 的开销，其将随着线程数量的增加很快变得明显，并且在高负载下愈演愈烈。此外，仅仅由于应用程序的整体复杂性
     * 或者并发需求，在项目的生命周期内也可能会出现其他和线程相关的问题。
     *
     * 简而言之，多线程处理是很复杂的。后续将会看到 Netty 是如何帮助简化它的。
     */
    public static void main(String[] args) {

    }

}
